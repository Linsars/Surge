// ==UserScript==
// @name         智慧重命名 - 支持 GPT 区判断（超级全面版）
// @version      1.2
// @description  为substore代理节点重命名，支持生肖/塔罗/罪/天使循环 + 对非港台&不支持GPT地区追加文字
// @author       Linsar
// ==/UserScript==
// 参数说明（用 # 开头，多个用 & 连接）
// QZ=      前缀文字（最前面）          示例：QZ=小林机场
// HZ=      后缀文字（最末尾）          示例：HZ=香港
// fgf=     分隔符（前缀/国旗/名字/序号 都用这个）  默认｜    示例：fgf=｜
// GM=      命名模式控制
//          GM=生肖      → 十二生肖循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=塔罗      → 塔罗牌（英文超简版，无 The）循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=塔罗X     → 塔罗牌（中文简洁版）循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=罪        → 七宗罪循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=天使      → 十二天使（英文名）循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=天使X     → 十二天使（中文名）循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=任意文字  → 全部使用你输入的文字作为基础名 + 重复时加¹²³…¹⁰¹¹…
//          不传或其它值 → 只加前缀/后缀，不改原名，也不加序号
// ZN=      是否对非港台&非GPT支持节点追加文字   1=开启，0=关闭（默认）   示例：ZN=1
// ZNre=    自定义追加的文本（仅 ZN=1 时生效，没传则用默认 " | GPT"）  示例：ZNre= | NF+GPT
// ======================================================================

const args = $arguments || {};

// ── 基础命名参数 ────────────────────────────────────────
const PREFIX    = args.QZ   ? decodeURI(args.QZ)   + (args.fgf || "｜") : "";
const SUFFIX    = args.HZ   ? (args.fgf || "｜") + decodeURI(args.HZ) : "";
const SEP       = args.fgf  ? decodeURI(args.fgf)  : "｜";

const GM_MODE   = args.GM ? decodeURI(args.GM).trim() : "";
const USE_CUSTOM = !!GM_MODE;

// ── 追加文字控制 ────────────────────────────────────────
const APPEND_ENABLED = (args.ZN === "1" || args.ZN === 1);

const DEFAULT_APPEND = " | GPT";
let APPEND_TEXT = DEFAULT_APPEND;

if (APPEND_ENABLED && args.ZNre !== undefined) {
    const custom = decodeURI(args.ZNre);
    if (custom.trim() !== "") {
        APPEND_TEXT = custom;
    }
}

// 香港/台湾 + 全球 OpenAI/ChatGPT 不支持/被禁地区关键词（不区分大小写，2026最新）
// 优先放常见节点命名写法：国家名、简称、城市、英文/中文
const hkTwKeywords = [
    // 香港/台湾（全面覆盖城市、机场代码、常见写法）
    '香港', '港', 'HK', 'HKG', 'HongKong', 'Hong Kong', 'Hong-Kong', '九龙', '新界',
    '台湾', '台灣', '台', 'TW', 'Taiwan', 'Taipei', 'TPE', 'TaiPei', '桃園', '桃园',
    '高雄', 'Kaohsiung', 'KHH', '台中', 'Taichung', 'RMQ', '台南', 'Tainan', 'TNN',
    '新北', '彰化', 'Changhua', '基隆', 'Keelung', '宜兰', '花莲', 'Hualien', '台东',

    // 中国大陆（最常见）
    '中国', '大陆', 'CN', 'China', 'Mainland', '北京', '上海', '广州', '深圳', '成都', '杭州',

    // OpenAI 明确不支持/被禁的主要国家（高频节点名）
    '俄罗斯', '俄国', 'RU', 'Russia', 'Moscow', '莫斯科', '圣彼得堡', 'SPB',
    '伊朗', 'IR', 'Iran', 'Tehran', '德黑兰', '波斯',
    '朝鲜', '北朝鲜', '北韩', 'KP', 'Korea North', 'DPRK', 'Pyongyang', '平壤',
    '古巴', 'Cuba', 'CU', 'Havana', '哈瓦那',
    '叙利亚', 'SY', 'Syria', 'Damascus', '大马士革',
    '阿富汗', 'AF', 'Afghanistan', 'Kabul', '喀布尔',
    '白俄罗斯', '白俄', 'BY', 'Belarus', 'Minsk', '明斯克',
    '缅甸', 'Burma', 'Myanmar', 'MM', 'Yangon', '仰光', '内比都',
    '利比亚', 'LY', 'Libya', 'Tripoli', '的黎波里',
    '也门', 'Yemen', 'YE', 'Sanaa',
    '苏丹', 'Sudan', 'SD', 'Khartoum',
    '厄立特里亚', 'ER', 'Eritrea',
    '中非', 'Central African Republic', 'CF',
    '乍得', 'Chad', 'TD',

    // 其他常见不支持/曾受限地区（节点命名中出现概率较高）
    '沙特', 'Saudi Arabia', 'SA', 'Riyadh', '利雅得',  // 曾波动
    '埃及', 'Egypt', 'EG', 'Cairo', '开罗',
    '老挝', 'Laos', 'LA', 'Vientiane',
    '哈萨克斯坦', 'Kazakhstan', 'KZ', 'Almaty', '阿拉木图',
    '埃塞俄比亚', 'Ethiopia', 'ET', 'Addis Ababa',
    '委内瑞拉', 'Venezuela', 'VE', 'Caracas',
    '巴林', 'Bahrain', 'BH',
    '吉布提', 'Djibouti',
    '马其顿', 'North Macedonia', 'MK',
    '南苏丹', 'South Sudan', 'SS'
];

const hkTwRegex = new RegExp(hkTwKeywords.join('|'), 'i');

// ── 循环命名数组 ────────────────────────────────────────
const ZODIAC = [
    "子鼠", "丑牛", "寅虎", "卯兔", "辰龙", "巳蛇",
    "午马", "未羊", "申猴", "酉鸡", "戌狗", "亥猪"
];

const TAROT_EN = [
    "Fool", "Magician", "High Priestess", "Empress", "Emperor", "Hierophant",
    "Lovers", "Chariot", "Strength", "Hermit", "Wheel of Fortune", "Justice",
    "Hanged Man", "Death", "Temperance", "Devil", "Tower", "Star",
    "Moon", "Sun", "Judgement", "World"
];

const TAROT_CN = [
    "愚者", "魔术师", "女祭司", "皇后", "皇帝", "教皇",
    "恋人", "战车", "力量", "隐士", "命运之轮", "正义",
    "倒吊人", "死神", "节制", "恶魔", "塔", "星星",
    "月亮", "太阳", "审判", "世界"
];

const SINS = [
    "傲慢", "嫉妒", "暴怒", "懒惰", "贪婪", "暴食", "色欲"
];

const ANGELS_EN = [
    "Michael", "Gabriel", "Raphael", "Uriel", "Raguel", "Sariel",
    "Remiel", "Zadkiel", "Jophiel", "Chamuel", "Haniel", "Barachiel"
];

const ANGELS_CN = [
    "米迦勒", "加百列", "拉斐尔", "乌列尔", "拉贵尔", "萨列尔",
    "雷米尔", "扎基尔", "约菲尔", "卡麦尔", "哈尼尔", "巴拉基勒"
];

const SUPER_DIGITS = {
    '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴',
    '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹'
};

function toSuperscript(num) {
    if (num <= 0) return '';
    const str = num.toString();
    let result = '';
    for (let char of str) {
        result += SUPER_DIGITS[char] || char;
    }
    return result;
}

function operator(proxies) {
    if (!proxies?.length) return proxies;

    let result = [];

    // 第一阶段：处理前缀 + 循环命名 / 序号
    if (!USE_CUSTOM) {
        proxies.forEach(proxy => {
            const newName = PREFIX + proxy.name.trim() + SUFFIX;
            proxy.name = newName;
            result.push(proxy);
        });
    } else {
        let getBaseName;

        if (GM_MODE === "生肖") {
            getBaseName = (index) => {
                const zIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let z = ZODIAC[zIdx];
                if (cycle > 0) z += cycle;
                return z;
            };
        }
        else if (GM_MODE === "塔罗") {
            getBaseName = (index) => {
                const tIdx = index % 22;
                const cycle = Math.floor(index / 22);
                let card = TAROT_EN[tIdx];
                if (cycle > 0) card += cycle;
                return card;
            };
        }
        else if (GM_MODE === "塔罗X") {
            getBaseName = (index) => {
                const tIdx = index % 22;
                const cycle = Math.floor(index / 22);
                let card = TAROT_CN[tIdx];
                if (cycle > 0) card += cycle;
                return card;
            };
        }
        else if (GM_MODE === "罪") {
            getBaseName = (index) => {
                const sIdx = index % 7;
                const cycle = Math.floor(index / 7);
                let sin = SINS[sIdx];
                if (cycle > 0) sin += cycle;
                return sin;
            };
        }
        else if (GM_MODE === "天使") {
            getBaseName = (index) => {
                const aIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let angel = ANGELS_EN[aIdx];
                if (cycle > 0) angel += cycle;
                return angel;
            };
        }
        else if (GM_MODE === "天使X") {
            getBaseName = (index) => {
                const aIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let angel = ANGELS_CN[aIdx];
                if (cycle > 0) angel += cycle;
                return angel;
            };
        }
        else {
            getBaseName = () => GM_MODE;
        }

        const nameGroups = {};
        proxies.forEach((proxy, idx) => {
            const base = getBaseName(idx);
            proxy._base = base;
            if (!nameGroups[base]) nameGroups[base] = [];
            nameGroups[base].push(proxy);
        });

        Object.keys(nameGroups).forEach(base => {
            const nodes = nameGroups[base];
            const count = nodes.length;

            nodes.forEach((node, i) => {
                let part = base;
                if (count > 1) {
                    const sup = toSuperscript(i + 1);
                    part += sup;
                }
                node.name = PREFIX + part + SUFFIX;
                delete node._base;
                result.push(node);
            });
        });
    }

    // 第二阶段：如果 ZN=1，则对**非港台 & 非支持区**节点追加 APPEND_TEXT
    if (APPEND_ENABLED) {
        result = result.map(p => {
            if (hkTwRegex.test(p.name)) {
                return p;  // 匹配到港台或不支持区关键词 → 不加
            }
            p.name += APPEND_TEXT;
            return p;
        });
    }

    return result;
}
