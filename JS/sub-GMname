// ==UserScript==
// 参数说明（用 # 开头，多个用 & 连接）
// QZ=      前缀文字（最前面）          示例：QZ=小林机场
// HZ=      后缀文字（最末尾）          示例：HZ=香港
// fgf=     分隔符（前缀/国旗/名字/序号 都用这个）  默认｜    示例：fgf=｜
// GM=      命名模式控制
//          GM=生肖      → 十二生肖循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=塔罗      → 塔罗牌（英文超简版，无 The）循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=塔罗X     → 塔罗牌（中文简洁版）循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=罪        → 七宗罪循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=天使      → 十二天使（英文名）循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=天使X     → 十二天使（中文名）循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=任意文字  → 全部使用你输入的文字作为基础名 + 重复时加¹²³…¹⁰¹¹…
//          不传或其它值 → 只加前缀/后缀，不改原名，也不加序号
// ZN=      是否对非港台节点追加文字   1=开启，0=关闭（默认）   示例：ZN=1
// ZNre=    自定义追加的文本（仅 ZN=1 时生效，没传则用默认 " | GPT"）  示例：ZNre= | NF+GPT
// ======================================================================

const args = $arguments || {};

// ── 基础命名参数 ────────────────────────────────────────
const PREFIX    = args.QZ   ? decodeURI(args.QZ)   + (args.fgf || "｜") : "";
const SUFFIX    = args.HZ   ? (args.fgf || "｜") + decodeURI(args.HZ) : "";
const SEP       = args.fgf  ? decodeURI(args.fgf)  : "｜";

const GM_MODE   = args.GM ? decodeURI(args.GM).trim() : "";
const USE_CUSTOM = !!GM_MODE;

// ── 追加文字控制 ────────────────────────────────────────
const APPEND_ENABLED = (args.ZN === "1" || args.ZN === 1);

const DEFAULT_APPEND = " | GPT";
let APPEND_TEXT = DEFAULT_APPEND;

if (APPEND_ENABLED && args.ZNre !== undefined) {
    const custom = decodeURI(args.ZNre);
    if (custom.trim() !== "") {  // 如果传了非空，才覆盖默认
        APPEND_TEXT = custom;
    }
    // 如果传了空字符串，就保持默认 " | GPT"
}

// 香港/台湾常见关键词（不区分大小写）
const hkTwKeywords = [
    '香港', '港', 'HK', 'HKG', 'HongKong', 'Hong Kong',
    '台湾', '台灣', '台', 'TW', 'Taiwan', 'Taipei', 'TPE',
    '新北', '桃园', '高雄', '台中', 'Kaohsiung', '台南', '彰化', '基隆'
];
const hkTwRegex = new RegExp(hkTwKeywords.join('|'), 'i');

// ── 循环命名数组 ────────────────────────────────────────
const ZODIAC = [
    "子鼠", "丑牛", "寅虎", "卯兔", "辰龙", "巳蛇",
    "午马", "未羊", "申猴", "酉鸡", "戌狗", "亥猪"
];

const TAROT_EN = [
    "Fool", "Magician", "High Priestess", "Empress", "Emperor", "Hierophant",
    "Lovers", "Chariot", "Strength", "Hermit", "Wheel of Fortune", "Justice",
    "Hanged Man", "Death", "Temperance", "Devil", "Tower", "Star",
    "Moon", "Sun", "Judgement", "World"
];

const TAROT_CN = [
    "愚者", "魔术师", "女祭司", "皇后", "皇帝", "教皇",
    "恋人", "战车", "力量", "隐士", "命运之轮", "正义",
    "倒吊人", "死神", "节制", "恶魔", "塔", "星星",
    "月亮", "太阳", "审判", "世界"
];

const SINS = [
    "傲慢", "嫉妒", "暴怒", "懒惰", "贪婪", "暴食", "色欲"
];

const ANGELS_EN = [
    "Michael", "Gabriel", "Raphael", "Uriel", "Raguel", "Sariel",
    "Remiel", "Zadkiel", "Jophiel", "Chamuel", "Haniel", "Barachiel"
];

const ANGELS_CN = [
    "米迦勒", "加百列", "拉斐尔", "乌列尔", "拉贵尔", "萨列尔",
    "雷米尔", "扎基尔", "约菲尔", "卡麦尔", "哈尼尔", "巴拉基勒"
];

const SUPER_DIGITS = {
    '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴',
    '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹'
};

function toSuperscript(num) {
    if (num <= 0) return '';
    const str = num.toString();
    let result = '';
    for (let char of str) {
        result += SUPER_DIGITS[char] || char;
    }
    return result;
}

function operator(proxies) {
    if (!proxies?.length) return proxies;

    let result = [];

    // 第一阶段：处理前缀 + 循环命名 / 序号
    if (!USE_CUSTOM) {
        proxies.forEach(proxy => {
            const newName = PREFIX + proxy.name.trim() + SUFFIX;
            proxy.name = newName;
            result.push(proxy);
        });
    } else {
        let getBaseName;

        if (GM_MODE === "生肖") {
            getBaseName = (index) => {
                const zIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let z = ZODIAC[zIdx];
                if (cycle > 0) z += cycle;
                return z;
            };
        }
        else if (GM_MODE === "塔罗") {
            getBaseName = (index) => {
                const tIdx = index % 22;
                const cycle = Math.floor(index / 22);
                let card = TAROT_EN[tIdx];
                if (cycle > 0) card += cycle;
                return card;
            };
        }
        else if (GM_MODE === "塔罗X") {
            getBaseName = (index) => {
                const tIdx = index % 22;
                const cycle = Math.floor(index / 22);
                let card = TAROT_CN[tIdx];
                if (cycle > 0) card += cycle;
                return card;
            };
        }
        else if (GM_MODE === "罪") {
            getBaseName = (index) => {
                const sIdx = index % 7;
                const cycle = Math.floor(index / 7);
                let sin = SINS[sIdx];
                if (cycle > 0) sin += cycle;
                return sin;
            };
        }
        else if (GM_MODE === "天使") {
            getBaseName = (index) => {
                const aIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let angel = ANGELS_EN[aIdx];
                if (cycle > 0) angel += cycle;
                return angel;
            };
        }
        else if (GM_MODE === "天使X") {
            getBaseName = (index) => {
                const aIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let angel = ANGELS_CN[aIdx];
                if (cycle > 0) angel += cycle;
                return angel;
            };
        }
        else {
            getBaseName = () => GM_MODE;
        }

        const nameGroups = {};
        proxies.forEach((proxy, idx) => {
            const base = getBaseName(idx);
            proxy._base = base;
            if (!nameGroups[base]) nameGroups[base] = [];
            nameGroups[base].push(proxy);
        });

        Object.keys(nameGroups).forEach(base => {
            const nodes = nameGroups[base];
            const count = nodes.length;

            nodes.forEach((node, i) => {
                let part = base;
                if (count > 1) {
                    const sup = toSuperscript(i + 1);
                    part += sup;
                }
                node.name = PREFIX + part + SUFFIX;
                delete node._base;
                result.push(node);
            });
        });
    }

    // 第二阶段：如果 ZN=1，则对非港台节点追加 APPEND_TEXT
    if (APPEND_ENABLED) {
        result = result.map(p => {
            if (hkTwRegex.test(p.name)) {
                return p;
            }
            p.name += APPEND_TEXT;
            return p;
        });
    }

    return result;
}
