// ==UserScript==
// @name         智慧重命名 - 支持 GPT 区判断（超级全面版）
// @version      1.3
// @description  为substore代理节点重命名，支持多种循环命名 + 对非港台&不支持GPT地区追加文字（参数不区分大小写）
// @author       Linsar
// ==/UserScript==
// 参数说明（用 # 开头，多个用 & 连接）
// QZ=      前缀文字（最前面）          示例：qz=小林机场 或 QZ=小林机场
// HZ=      后缀文字（最末尾）          示例：hz=香港
// fgf=     分隔符（前缀/国旗/名字/序号 都用这个）  默认｜    示例：fgf=｜ 或 FGF= - 
// GM=      命名模式控制（不区分大小写）
//          GM=生肖      → 十二生肖循环 + 重复时加¹²³…¹⁰¹¹…
//          GM=塔罗      → 塔罗牌（英文超简版，无 The）循环
//          GM=塔罗X     → 塔罗牌（中文简洁版）循环
//          GM=罪        → 七宗罪循环
//          GM=天使      → 十二天使（英文名）循环
//          GM=天使X     → 十二天使（中文名）循环
//          GM=血族      → 西方吸血鬼传说阶位（简洁英文）循环
//          GM=节气      → 中国古代二十四节气循环
//          GM=唐朝      → 中国古代唐朝官职循环
//          GM=斗罗      → 小说斗破苍穹中等级循环
//          GM=斗破      → 小说斗罗大陆中等级循环
//          GM=任意文字  → 全部使用你输入的文字作为基础名 + 重复时加序号
//          不传或其它值 → 只加前缀/后缀，不改原名，也不加序号
// ZN=      是否对非港台&非GPT支持节点追加文字   1=开启，0=关闭（默认）   示例：zn=1
// ZNre=    自定义追加的文本（仅 ZN=1 时生效，没传则用默认 " | GPT"）  示例：znre= | NF+GPT
// ======================================================================

const args = $arguments || {};

// 将所有参数 key 转为大写，方便不区分大小写处理
const args_upper = {};
for (const key in args) {
    if (Object.prototype.hasOwnProperty.call(args, key)) {
        args_upper[key.toUpperCase()] = args[key];
    }
}

// ── 基础命名参数 ────────────────────────────────────────
const PREFIX = args_upper.QZ   ? decodeURI(args_upper.QZ)   + (args_upper.FGF || "｜") : "";
const SUFFIX = args_upper.HZ   ? (args_upper.FGF || "｜") + decodeURI(args_upper.HZ) : "";
const SEP    = args_upper.FGF  ? decodeURI(args_upper.FGF)  : "｜";

const GM_MODE   = args_upper.GM ? decodeURI(args_upper.GM).trim() : "";
const USE_CUSTOM = !!GM_MODE;

// ── 追加文字控制 ────────────────────────────────────────
const APPEND_ENABLED = (args_upper.ZN === "1" || args_upper.ZN === 1);

const DEFAULT_APPEND = " | GPT";
let APPEND_TEXT = DEFAULT_APPEND;

if (APPEND_ENABLED && args_upper.ZNRE !== undefined) {
    const custom = decodeURI(args_upper.ZNRE);
    if (custom.trim() !== "") {
        APPEND_TEXT = custom;
    }
}

// 香港/台湾 + 全球 OpenAI/ChatGPT 不支持/被禁地区关键词（不区分大小写，2026最新）
const hkTwKeywords = [
    '香港', '港', 'HK', 'HKG', 'HongKong', 'Hong Kong', 'Hong-Kong', '九龙', '新界',
    '台湾', '台灣', '台', 'TW', 'Taiwan', 'Taipei', 'TPE', 'TaiPei', '桃園', '桃园',
    '高雄', 'Kaohsiung', 'KHH', '台中', 'Taichung', 'RMQ', '台南', 'Tainan', 'TNN',
    '新北', '彰化', 'Changhua', '基隆', 'Keelung', '宜兰', '花莲', 'Hualien', '台东',
    '中国', '大陆', 'CN', 'China', 'Mainland', '北京', '上海', '广州', '深圳', '成都', '杭州',
    '俄罗斯', '俄国', 'RU', 'Russia', 'Moscow', '莫斯科', '圣彼得堡', 'SPB',
    '伊朗', 'IR', 'Iran', 'Tehran', '德黑兰', '波斯',
    '朝鲜', '北朝鲜', '北韩', 'KP', 'Korea North', 'DPRK', 'Pyongyang', '平壤',
    '古巴', 'Cuba', 'CU', 'Havana', '哈瓦那',
    '叙利亚', 'SY', 'Syria', 'Damascus', '大马士革',
    '阿富汗', 'AF', 'Afghanistan', 'Kabul', '喀布尔',
    '白俄罗斯', '白俄', 'BY', 'Belarus', 'Minsk', '明斯克',
    '缅甸', 'Burma', 'Myanmar', 'MM', 'Yangon', '仰光', '内比都',
    '利比亚', 'LY', 'Libya', 'Tripoli', '的黎波里',
    '也门', 'Yemen', 'YE', 'Sanaa',
    '苏丹', 'Sudan', 'SD', 'Khartoum',
    '厄立特里亚', 'ER', 'Eritrea',
    '中非', 'Central African Republic', 'CF',
    '乍得', 'Chad', 'TD',
    '沙特', 'Saudi Arabia', 'SA', 'Riyadh', '利雅得',
    '埃及', 'Egypt', 'EG', 'Cairo', '开罗',
    '老挝', 'Laos', 'LA', 'Vientiane',
    '哈萨克斯坦', 'Kazakhstan', 'KZ', 'Almaty', '阿拉木图',
    '埃塞俄比亚', 'Ethiopia', 'ET', 'Addis Ababa',
    '委内瑞拉', 'Venezuela', 'VE', 'Caracas',
    '巴林', 'Bahrain', 'BH',
    '吉布提', 'Djibouti',
    '马其顿', 'North Macedonia', 'MK',
    '南苏丹', 'South Sudan', 'SS'
];

const hkTwRegex = new RegExp(hkTwKeywords.join('|'), 'i');

// ── 循环命名数组 ────────────────────────────────────────
const ZODIAC = [
    "子鼠", "丑牛", "寅虎", "卯兔", "辰龙", "巳蛇",
    "午马", "未羊", "申猴", "酉鸡", "戌狗", "亥猪"
];

const TAROT_EN = [
    "Fool", "Magician", "High Priestess", "Empress", "Emperor", "Hierophant",
    "Lovers", "Chariot", "Strength", "Hermit", "Wheel of Fortune", "Justice",
    "Hanged Man", "Death", "Temperance", "Devil", "Tower", "Star",
    "Moon", "Sun", "Judgement", "World"
];

const TAROT_CN = [
    "愚者", "魔术师", "女祭司", "皇后", "皇帝", "教皇",
    "恋人", "战车", "力量", "隐士", "命运之轮", "正义",
    "倒吊人", "死神", "节制", "恶魔", "塔", "星星",
    "月亮", "太阳", "审判", "世界"
];

const SINS = [
    "傲慢", "嫉妒", "暴怒", "懒惰", "贪婪", "暴食", "色欲"
];

const ANGELS_EN = [
    "Michael", "Gabriel", "Raphael", "Uriel", "Raguel", "Sariel",
    "Remiel", "Zadkiel", "Jophiel", "Chamuel", "Haniel", "Barachiel"
];

const ANGELS_CN = [
    "米迦勒", "加百列", "拉斐尔", "乌列尔", "拉贵尔", "萨列尔",
    "雷米尔", "扎基尔", "约菲尔", "卡麦尔", "哈尼尔", "巴拉基勒"
];

const VAMPIRE_RANKS = [
    "Fledgling", "Neonate", "Ancilla", "Elder", "Methuselah", "Antediluvian",
    "Baron", "Count", "Duke", "Prince", "Archon", "Justicar"
];

const SOLAR_TERMS = [
    "立春", "雨水", "惊蛰", "春分", "清明", "谷雨",
    "立夏", "小满", "芒种", "夏至", "小暑", "大暑",
    "立秋", "处暑", "白露", "秋分", "寒露", "霜降",
    "立冬", "小雪", "大雪", "冬至", "小寒", "大寒"
];

const TANG_OFFICIALS = [
    "宰相", "尚书", "侍郎", "郎中", "员外郎", "御史", "太守", "刺史",
    "县令", "主簿", "司空", "司徒", "司马", "太尉", "中书令", "门下侍中",
    "尚书令", "给事中", "谏议大夫", "大夫", "卿", "将军", "校尉", "都督"
];

const DOUPO_LEVELS = [
    "斗之气", "斗者", "斗师", "大斗师", "斗灵", "斗王",
    "斗皇", "斗宗", "斗尊", "斗圣", "斗帝"
];

const DOULUO_LEVELS = [
    "魂士", "魂师", "大魂师", "魂尊", "魂宗", "魂王",
    "魂帝", "魂圣", "魂斗罗", "封号斗罗", "神级"
];

const SUPER_DIGITS = {
    '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴',
    '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹'
};

function toSuperscript(num) {
    if (num <= 0) return '';
    const str = num.toString();
    let result = '';
    for (let char of str) {
        result += SUPER_DIGITS[char] || char;
    }
    return result;
}

function operator(proxies) {
    if (!proxies?.length) return proxies;

    let result = [];

    // 第一阶段：处理前缀 + 循环命名 / 序号
    if (!USE_CUSTOM) {
        proxies.forEach(proxy => {
            const newName = PREFIX + proxy.name.trim() + SUFFIX;
            proxy.name = newName;
            result.push(proxy);
        });
    } else {
        let getBaseName;

        if (GM_MODE === "生肖") {
            getBaseName = (index) => {
                const zIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let z = ZODIAC[zIdx];
                if (cycle > 0) z += cycle;
                return z;
            };
        }
        else if (GM_MODE === "塔罗") {
            getBaseName = (index) => {
                const tIdx = index % 22;
                const cycle = Math.floor(index / 22);
                let card = TAROT_EN[tIdx];
                if (cycle > 0) card += cycle;
                return card;
            };
        }
        else if (GM_MODE === "塔罗X") {
            getBaseName = (index) => {
                const tIdx = index % 22;
                const cycle = Math.floor(index / 22);
                let card = TAROT_CN[tIdx];
                if (cycle > 0) card += cycle;
                return card;
            };
        }
        else if (GM_MODE === "罪") {
            getBaseName = (index) => {
                const sIdx = index % 7;
                const cycle = Math.floor(index / 7);
                let sin = SINS[sIdx];
                if (cycle > 0) sin += cycle;
                return sin;
            };
        }
        else if (GM_MODE === "天使") {
            getBaseName = (index) => {
                const aIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let angel = ANGELS_EN[aIdx];
                if (cycle > 0) angel += cycle;
                return angel;
            };
        }
        else if (GM_MODE === "天使X") {
            getBaseName = (index) => {
                const aIdx = index % 12;
                const cycle = Math.floor(index / 12);
                let angel = ANGELS_CN[aIdx];
                if (cycle > 0) angel += cycle;
                return angel;
            };
        }
        else if (GM_MODE === "血族") {
            getBaseName = (index) => {
                const vIdx = index % VAMPIRE_RANKS.length;
                const cycle = Math.floor(index / VAMPIRE_RANKS.length);
                let rank = VAMPIRE_RANKS[vIdx];
                if (cycle > 0) rank += cycle;
                return rank;
            };
        }
        else if (GM_MODE === "节气") {
            getBaseName = (index) => {
                const sIdx = index % SOLAR_TERMS.length;
                const cycle = Math.floor(index / SOLAR_TERMS.length);
                let term = SOLAR_TERMS[sIdx];
                if (cycle > 0) term += cycle;
                return term;
            };
        }
        else if (GM_MODE === "唐朝") {
            getBaseName = (index) => {
                const oIdx = index % TANG_OFFICIALS.length;
                const cycle = Math.floor(index / TANG_OFFICIALS.length);
                let official = TANG_OFFICIALS[oIdx];
                if (cycle > 0) official += cycle;
                return official;
            };
        }
        else if (GM_MODE === "斗罗") {
            getBaseName = (index) => {
                const dIdx = index % DOUPO_LEVELS.length;
                const cycle = Math.floor(index / DOUPO_LEVELS.length);
                let level = DOUPO_LEVELS[dIdx];
                if (cycle > 0) level += cycle;
                return level;
            };
        }
        else if (GM_MODE === "斗破") {
            getBaseName = (index) => {
                const dIdx = index % DOULUO_LEVELS.length;
                const cycle = Math.floor(index / DOULUO_LEVELS.length);
                let level = DOULUO_LEVELS[dIdx];
                if (cycle > 0) level += cycle;
                return level;
            };
        }
        else {
            getBaseName = () => GM_MODE;
        }

        const nameGroups = {};
        proxies.forEach((proxy, idx) => {
            const base = getBaseName(idx);
            proxy._base = base;
            if (!nameGroups[base]) nameGroups[base] = [];
            nameGroups[base].push(proxy);
        });

        Object.keys(nameGroups).forEach(base => {
            const nodes = nameGroups[base];
            const count = nodes.length;

            nodes.forEach((node, i) => {
                let part = base;
                if (count > 1) {
                    const sup = toSuperscript(i + 1);
                    part += sup;
                }
                node.name = PREFIX + part + SUFFIX;
                delete node._base;
                result.push(node);
            });
        });
    }

    // 第二阶段：如果 ZN=1，则对**非港台 & 非支持区**节点追加 APPEND_TEXT
    if (APPEND_ENABLED) {
        result = result.map(p => {
            if (hkTwRegex.test(p.name)) {
                return p;  // 匹配到港台或不支持区关键词 → 不加
            }
            p.name += APPEND_TEXT;
            return p;
        });
    }

    return result;
}
